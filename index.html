<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>N-Node IK Chain Lab</title>
  <style>
    body {
      margin: 0;
      background: #121212;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
    }
    #ikCanvas {
      background: #000; /* ì´ë¯¸ì§€ ì—†ê±°ë‚˜ ì‹¤íŒ¨ì‹œ ê²€ì • */
      margin-top: 10px;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      border: 1px solid #333;
    }
    .panel {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      background: #1b1b1b;
      padding: 8px 14px;
      border-radius: 10px;
      border: 1px solid #333;
      max-width: 900px;
      font-size: 12px;
      align-items: center;
    }
    .panel .status {
      margin-right: 12px;
      color: #b0bec5;
      font-size: 12px;
    }
    .panel button {
      padding: 6px 12px;
      border-radius: 6px;
      border: none;
      background: #42a5f5;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
    }
    .panel button:disabled {
      background: #555;
      cursor: default;
    }
    .panel button:hover:not(:disabled) {
      background: #1e88e5;
    }

    .subpanel {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      background: #171717;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #333;
      max-width: 900px;
      font-size: 11px;
      align-items: center;
    }
    .field {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .field label {
      min-width: 70px;
      color: #bbb;
      font-size: 11px;
    }
    .field input {
      width: 140px;
      background: #262626;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 2px 4px;
      color: #eee;
      font-size: 11px;
    }
    .small-input {
      width: 60px !important;
    }
    .subpanel button {
      padding: 5px 10px;
      border-radius: 6px;
      border: none;
      background: #7e57c2;
      color: #fff;
      font-size: 11px;
      cursor: pointer;
    }
    .subpanel button:hover {
      background: #5e35b1;
    }

    .info {
      margin-top: 6px;
      font-size: 13px;
      text-align: center;
      line-height: 1.4;
      color: #ccc;
    }
  </style>
</head>
<body>
  <canvas id="ikCanvas" width="800" height="400"></canvas>

  <!-- ìƒë‹¨: ë¹Œë“œ & ëª¨ë“œ ìƒíƒœ -->
  <div class="panel">
    <span class="status" id="modeLabel">
      Mode: Building (ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ì„œ ë…¸ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”)
    </span>
    <span class="status" id="nodeCountLabel">
      Nodes: 0
    </span>
    <button id="resetBtn">Reset Nodes</button>
    <button id="applyBtn" disabled>Apply System</button>
  </div>

  <!-- ë°°ê²½ + Advanced -->
  <div class="subpanel">
    <div class="field" style="flex: 1 1 260px;">
      <label>Image URL</label>
      <input id="bgUrl" type="text" placeholder="https://example.com/image.jpg">
    </div>
    <button id="loadBgBtn">Load Image</button>

    <div class="field">
      <label>alpha (0~1)</label>
      <input id="alphaInput" class="small-input" type="number" step="0.05" value="0.25">
    </div>
    <div class="field">
      <label>iterations</label>
      <input id="iterInput" class="small-input" type="number" value="10">
    </div>
    <div class="field">
      <label>moveFactor</label>
      <input id="moveInput" class="small-input" type="number" step="0.1" value="1.0">
    </div>
  </div>

  <div class="info">
    ğŸ“Œ Building ëª¨ë“œ: ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ì„œ 0,1,2,...,N-1 ë²ˆ ë…¸ë“œë¥¼ ìˆœì„œëŒ€ë¡œ ì°ìŠµë‹ˆë‹¤. (ìµœì†Œ 2ê°œ)<br/>
    Apply Systemì„ ëˆ„ë¥´ë©´ 0ë²ˆê³¼ (N-1)ë²ˆ ë…¸ë“œê°€ ê³ ì •ë˜ê³ , ì¤‘ê°„ ë…¸ë“œë¥¼ ë“œë˜ê·¸í•˜ë©´ IKë¡œ ì„œì„œíˆ ë”°ë¼ì˜µë‹ˆë‹¤.<br/>
    ë°°ê²½ ì´ë¯¸ì§€ëŠ” URL + Load Imageë¡œ ë„£ì„ ìˆ˜ ìˆìœ¼ë©°, ë¹„ìœ¨ì— ë§ê²Œ ìº”ë²„ìŠ¤ í¬ê¸°ê°€ ì¡°ì •ë©ë‹ˆë‹¤.
  </div>

  <script>
    const canvas = document.getElementById('ikCanvas');
    const ctx = canvas.getContext('2d');

    const modeLabel = document.getElementById('modeLabel');
    const nodeCountLabel = document.getElementById('nodeCountLabel');
    const resetBtn = document.getElementById('resetBtn');
    const applyBtn = document.getElementById('applyBtn');

    const bgUrlInput = document.getElementById('bgUrl');
    const loadBgBtn = document.getElementById('loadBgBtn');

    const alphaInput = document.getElementById('alphaInput');
    const iterInput = document.getElementById('iterInput');
    const moveInput = document.getElementById('moveInput');

    // ---- ìƒíƒœ ----
    let bgImage = null;
    let bgLoaded = false;

    let nodes = [];       // {x, y, fixed: bool}
    let lengths = [];     // segment lengths: length between i and i+1
    let buildingMode = true;   // ë…¸ë“œ ìƒì„± ëª¨ë“œ
    let systemActive = false;  // IK ì‹œìŠ¤í…œ í™œì„± ì—¬ë¶€

    let alpha = 0.25;          // ìˆ˜ë ´ ì†ë„
    let iterations = 10;       // ê¸¸ì´ ì œì•½ ë°˜ë³µ íšŸìˆ˜
    let moveFactor = 1.0;      // íƒ€ê²Ÿìœ¼ë¡œ ëŒì–´ë‹¹ê¸°ëŠ” ê°•ë„

    let dragTarget = null;     // {index, x, y} or null
    let dragging = false;

    // ---- ìœ í‹¸ ----
    function dist(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    function updateStatusLabels() {
      nodeCountLabel.textContent = `Nodes: ${nodes.length}`;
      if (buildingMode) {
        modeLabel.textContent = "Mode: Building (ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ì„œ ë…¸ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”)";
      } else if (systemActive) {
        modeLabel.textContent = "Mode: IK (ì¤‘ê°„ ë…¸ë“œë¥¼ ë“œë˜ê·¸í•´ì„œ ì›€ì§ì´ì„¸ìš”)";
      } else {
        modeLabel.textContent = "Mode: Idle";
      }

      applyBtn.disabled = !(buildingMode && nodes.length >= 2);
    }

    // ---- ë…¸ë“œ ì´ˆê¸°í™”/ë¦¬ì…‹ ----
    function resetNodes() {
      nodes = [];
      lengths = [];
      buildingMode = true;
      systemActive = false;
      dragging = false;
      dragTarget = null;
      updateStatusLabels();
    }

    // ---- Advanced ì„¤ì • Apply (ì…ë ¥ê°’ ì½ê¸°) ----
    function applyAdvancedSettingsFromInputs() {
      const toNum = (el, fallback) => {
        const v = parseFloat(el.value);
        return Number.isFinite(v) ? v : fallback;
      };
      alpha = toNum(alphaInput, 0.25);
      if (alpha <= 0) alpha = 0.1;
      if (alpha > 1) alpha = 1;

      iterations = Math.round(toNum(iterInput, 10));
      if (iterations < 1) iterations = 1;

      moveFactor = toNum(moveInput, 1.0);
      if (moveFactor <= 0) moveFactor = 0.1;
    }

    // ---- ê¸¸ì´ ë°°ì—´ ê³„ì‚° ----
    function recomputeLengths() {
      lengths = [];
      for (let i = 0; i < nodes.length - 1; i++) {
        lengths.push(dist(nodes[i], nodes[i+1]));
      }
    }

    // ---- PBD ìŠ¤íƒ€ì¼ ê¸¸ì´ì œì•½ + íƒ€ê²Ÿìœ¼ë¡œ ëŒê¸° ----
    function solveTowardsTarget(targetIndex, targetX, targetY) {
      const n = nodes.length;
      if (n < 2) return nodes;

      // í´ë¡ 
      const P = nodes.map(p => ({ x: p.x, y: p.y, fixed: p.fixed }));

      // 1) íƒ€ê²Ÿ ë…¸ë“œë¥¼ ëª©ì ì§€ë¡œ ì´ë™ (ê°•ë„ ì¡°ì ˆ)
      const t = P[targetIndex];
      t.x += moveFactor * (targetX - t.x);
      t.y += moveFactor * (targetY - t.y);

      // 2) ì—¬ëŸ¬ ë²ˆ ê¸¸ì´ ì œì•½ ë°˜ë³µ
      for (let iter = 0; iter < iterations; iter++) {
        for (let i = 0; i < n - 1; i++) {
          const a = P[i];
          const b = P[i+1];
          const rest = lengths[i];

          let dx = b.x - a.x;
          let dy = b.y - a.y;
          let d = Math.hypot(dx, dy);
          if (d === 0) continue;

          const diff = (d - rest) / d;  // ì–‘ìˆ˜ë©´ ëŠ˜ì–´ë‚¬ë‹¤ëŠ” ëœ»

          const invMassA = a.fixed ? 0 : 1;
          const invMassB = b.fixed ? 0 : 1;
          const invSum = invMassA + invMassB;
          if (invSum === 0) continue;

          const offsetX = diff * dx;
          const offsetY = diff * dy;

          if (invMassA > 0) {
            a.x += -offsetX * (invMassA / invSum);
            a.y += -offsetY * (invMassA / invSum);
          }
          if (invMassB > 0) {
            b.x +=  offsetX * (invMassB / invSum);
            b.y +=  offsetY * (invMassB / invSum);
          }
        }
      }
      return P;
    }

    // ---- ë“œë¡œì‰ ----
    function draw() {
      // ë°°ê²½
      if (bgLoaded && bgImage) {
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // ë¹Œë”© ëª¨ë“œë“  IK ëª¨ë“œë“ , í˜„ì¬ nodesë¥¼ ê·¸ë¦¬ì
      if (nodes.length > 0) {
        // ë¼ì¸
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#4fc3f7';
        ctx.beginPath();
        ctx.moveTo(nodes[0].x, nodes[0].y);
        for (let i = 1; i < nodes.length; i++) {
          ctx.lineTo(nodes[i].x, nodes[i].y);
        }
        ctx.stroke();

        // ë…¸ë“œ
        nodes.forEach((node, i) => {
          ctx.beginPath();
          const isTarget = dragTarget && dragTarget.index === i;
          const r = isTarget ? 8 : 6;

          if (!systemActive) {
            // ì•„ì§ ì‹œìŠ¤í…œ ë¯¸ì ìš©: ì „ë¶€ ë™ì¼ìƒ‰
            ctx.fillStyle = isTarget ? '#ff5252' : '#90caf9';
          } else {
            // ì‹œìŠ¤í…œ ì ìš© í›„: ëì /ì¤‘ê°„ìƒ‰ êµ¬ë¶„
            if (i === 0 || i === nodes.length - 1) {
              ctx.fillStyle = isTarget ? '#ffca28' : '#b0bec5';
            } else {
              ctx.fillStyle = isTarget ? '#ff5252' : '#64b5f6';
            }
          }
          ctx.arc(node.x, node.y, r, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#fff';
          ctx.font = '11px system-ui';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(i.toString(), node.x, node.y - r - 2);
        });
      }

      // ë¹Œë”© ëª¨ë“œ ì•ˆë‚´ í…ìŠ¤íŠ¸ (ìº”ë²„ìŠ¤ ì•ˆì— ì‚´ì§)
      if (buildingMode) {
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = '12px system-ui';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Click to add nodes in order (0,1,2,...).', 10, 10);
      }
    }

    // ---- ì´ë²¤íŠ¸: ìº”ë²„ìŠ¤ í´ë¦­/ë“œë˜ê·¸ ----
    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e);

      if (buildingMode) {
        // ë…¸ë“œ ì°ê¸°
        nodes.push({ x: pos.x, y: pos.y, fixed: false });
        updateStatusLabels();
        draw();
        return;
      }

      if (!systemActive) return;

      // IK ëª¨ë“œ: ì¤‘ê°„ ë…¸ë“œë§Œ ë“œë˜ê·¸ ê°€ëŠ¥ (1 ~ N-2)
      if (nodes.length < 3) return;

      let closestIdx = null;
      let closestDist = Infinity;

      for (let i = 1; i < nodes.length - 1; i++) {
        const d = dist(nodes[i], pos);
        if (d < closestDist) {
          closestDist = d;
          closestIdx = i;
        }
      }

      if (closestIdx !== null && closestDist < 20) {
        dragging = true;
        dragTarget = { index: closestIdx, x: pos.x, y: pos.y };
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!dragging || !dragTarget) return;
      const pos = getMousePos(e);
      dragTarget.x = pos.x;
      dragTarget.y = pos.y;
    });

    canvas.addEventListener('mouseup', () => {
      dragging = false;
      dragTarget = null;
    });

    canvas.addEventListener('mouseleave', () => {
      dragging = false;
      dragTarget = null;
    });

    // ---- ë²„íŠ¼: Reset ----
    resetBtn.addEventListener('click', () => {
      resetNodes();
    });

    // ---- ë²„íŠ¼: Apply System ----
    applyBtn.addEventListener('click', () => {
      if (nodes.length < 2) return;
      // 0, N-1 ê³ ì •
      nodes.forEach((n, i) => {
        n.fixed = (i === 0 || i === nodes.length - 1);
      });
      recomputeLengths();
      buildingMode = false;
      systemActive = true;
      dragging = false;
      dragTarget = null;
      updateStatusLabels();
    });

    // ---- Advanced ì…ë ¥ ë³€ê²½ì‹œ ì¦‰ì‹œ ë°˜ì˜ (ì›í•˜ë©´ Apply ë²„íŠ¼ìœ¼ë¡œ ë°”ê¿”ë„ ë¨) ----
    alphaInput.addEventListener('change', applyAdvancedSettingsFromInputs);
    iterInput.addEventListener('change', applyAdvancedSettingsFromInputs);
    moveInput.addEventListener('change', applyAdvancedSettingsFromInputs);
    applyAdvancedSettingsFromInputs();

    // ---- ë°°ê²½ ì´ë¯¸ì§€ ë¡œë”© ----
    loadBgBtn.addEventListener('click', () => {
      const url = bgUrlInput.value.trim();
      if (!url) {
        bgImage = null;
        bgLoaded = false;
        return;
      }

      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        const oldW = canvas.width;
        const oldH = canvas.height;

        bgImage = img;
        bgLoaded = true;

        const maxW = 900;
        const maxH = 600;
        let w = img.width;
        let h = img.height;
        const scale = Math.min(maxW / w, maxH / h, 1);
        w = Math.round(w * scale);
        h = Math.round(h * scale);

        canvas.width = w;
        canvas.height = h;

        // ê¸°ì¡´ ë…¸ë“œê°€ ìˆë‹¤ë©´ ë¹„ìœ¨ì— ë§ê²Œ ìŠ¤ì¼€ì¼ë§
        if (nodes.length > 0 && oldW > 0 && oldH > 0) {
          const sx = w / oldW;
          const sy = h / oldH;
          nodes.forEach(n => {
            n.x *= sx;
            n.y *= sy;
          });
          if (systemActive) {
            // ê¸¸ì´ ë‹¤ì‹œ ê³„ì‚° (ìŠ¤ì¼€ì¼ ë°˜ì˜)
            recomputeLengths();
          }
        }

        draw();
      };
      img.onerror = () => {
        bgImage = null;
        bgLoaded = false;
      };
      img.src = url;
    });

    // ---- ë©”ì¸ ë£¨í”„ ----
    function loop() {
      if (systemActive && dragTarget) {
        const sol = solveTowardsTarget(dragTarget.index, dragTarget.x, dragTarget.y);
        if (sol) {
          // ë¶€ë“œëŸ½ê²Œ ìˆ˜ë ´
          for (let i = 0; i < nodes.length; i++) {
            nodes[i].x += alpha * (sol[i].x - nodes[i].x);
            nodes[i].y += alpha * (sol[i].y - nodes[i].y);
          }
        }
      }
      draw();
      requestAnimationFrame(loop);
    }

    // ì´ˆê¸° ìƒíƒœ
    resetNodes();
    draw();
    loop();
  </script>
</body>
</html>
